

这篇文章讲的很详细：

参考文章:

>http://dongxicheng.org/structure/bitmap/

>http://www.iteblog.com/archives/148

>**bitmap与位排序法**
>http://blog.sina.com.cn/s/blog_64a0208701011asp.html

>【算法设计-散列表】散列表的直接定址法与位向量
>http://www.aliog.com/3041.html

>大数据处理算法一：BITMAP算法
>http://www.cnphp6.com/archives/85585

>**Bit-map法处理大数据问题** 【这篇文章还可以进行深入挖掘】
>http://www.cnblogs.com/webary/p/4733247.html

参考资料:  
（1）     《C实现bitmap位图》：
http://blog.csdn.net/QIBAOYUAN/archive/2010/09/29/5914662.aspx  

（2）     武森《浅谈信息学竞赛中的“0”和“1”》

## 位图法的缺点

可读性差  
位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。

位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。

---

## 位图法的应用

1、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中
首先，将这40亿个数字存储到bitmap中，然后对于给出的数，判断是否在bitmap中即可。 
 
2、使用位图法判断整形数组是否存在重复  
遍历数组，一个一个放入bitmap，并且检查其是否在bitmap中出现过，如果没出现放入，否则即为重复的元素。 
 
3、使用位图法进行整形数组排序  
首先遍历数组，得到数组的最大最小值，然后根据这个最大最小值来缩小bitmap的范围。这里需要注意对于int的负数，都要转化为unsigned int来处理，而且取位的时候，数字要减去最小值。  

4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数  
参考的一个方法是：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。其实，这里可以使用两个普 通的Bitmap，即第一个Bitmap存储的是整数是否出现，如果再次出现，则在第二个Bitmap中设置即可。这样的话，就可以使用简单的1- Bitmap了。

3.2   搜索
设计搜索剪枝时，需要保存已经搜索过的历史信息，有些情况下，可以使用位图减小历史信息数据所占空间。

3.3    压缩  
（1）     在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数？  

（2）     腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？